AWSTemplateFormatVersion: '2010-09-09'
Description: Creates an AWS Backup Vault and a Lambda that triggers a subsequent copy to another account upon backup receipt.

Parameters:

  Environment:
    Type: String
    Description: The environment (e.g., Dev, Stage, Prod) for resource tagging.
    Default: Dev
    AllowedValues:
      - Dev
      - Stage
      - Prod

  OrganizationId:
    Type: String
    Description: Your AWS Organization ID (e.g., o-xxxxxxxxxx).
    AllowedPattern: '^o-[a-z0-9]{10,32}$'
    ConstraintDescription: Must be a valid AWS Organization ID.

  Identifier:
    Type: String
    Description: adding resources identifiers

  # New parameters for the Copy Logic
  SecondaryVaultArn:
    Type: String
    Description: The ARN of the destination vault (in the third account) where the backup should be forwarded.
    Default: ""

  # BackupServiceRoleArn:
  #   Type: String
  #   Description: The ARN of the IAM Role used for permissions (must match the role used in the event for PassRole validation).

  EnableCopyTrigger:
    Type: String
    Description: Set to 'true' to enable automatic copying of completed backups.
    Default: "false"
    AllowedValues:
      - "true"
      - "false"

  DestinationRetentionDays:
    Type: Number
    Description: The number of days to retain the backup copy in the secondary vault.
    Default: 30

Resources:

  KmsKeyForBackup:
    Type: AWS::KMS::Key
    Properties:
      Description: !Sub 'KMS key for encrypting ${Environment} AWS Backup vaults, shareable across the organization'
      KeyPolicy:
        Version: '2012-10-17'
        Statement:
          # Statement 1: Allows full control for the root user of this account
          - Sid: AllowFullControlForRoot
            Effect: Allow
            Principal:
              AWS: !Sub 'arn:aws:iam::${AWS::AccountId}:root'
            Action: 'kms:*'
            Resource: '*'

          # Statement 2: Allows AWS Backup to use the key
          - Sid: AllowBackupService
            Effect: Allow
            Principal:
              Service: backup.amazonaws.com
            Action:
              - 'kms:*'
            Resource: '*'

          # Statement 3: Allows all principals in your AWS Organization to use the key for crypto operations
          - Sid: AllowCryptoUseForOrganization
            Effect: Allow
            Principal:
              AWS: '*'
            Action:
              - 'kms:*'
            Resource: '*'
            Condition:
              StringEquals:
                'aws:PrincipalOrgID': !Ref OrganizationId
      
      EnableKeyRotation: false
      Tags:
        - Key: Name
          Value: !Sub '${Identifier}-backup-kms-key-${Environment}'
        - Key: Environment
          Value: !Ref Environment
        - Key: Purpose
          Value: 'AWS Backup Encryption'

  KmsKeyAlias:
    Type: AWS::KMS::Alias
    Properties:
      AliasName: !Sub 'alias/aws-backup-key-${Identifier}-${Environment}'
      TargetKeyId: !Ref KmsKeyForBackup

  EncryptedBackupVault:
    Type: AWS::Backup::BackupVault
    Properties:
      BackupVaultName: !Sub '${Identifier}-backup-vault-${Environment}'
      # Reference the ARN of the KMS key created in this template
      EncryptionKeyArn: !GetAtt KmsKeyForBackup.Arn
      AccessPolicy:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              AWS: !Sub 'arn:aws:iam::137708847303:role/CustomBackupServiceRole' # giving access to the role in the AUDIT account
            Action: 'backup:CopyIntoBackupVault'
            Resource: "*"

  # ---------------------------------------------------------
  # Lambda Resources
  # ---------------------------------------------------------

  BackupLoggerRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      # Added inline policy to allow the Lambda to trigger AWS Backup copy jobs
      Policies:
        - PolicyName: AllowBackupCopyTrigger
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action: backup:StartCopyJob
                Resource: "*"
              - Effect: Allow
                Action: iam:PassRole
                Resource: !Sub "arn:aws:iam::${AWS::AccountId}:role/CustomBackupServiceRole"

  BackupLoggerFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${Identifier}-backup-logger-${Environment}'
      Handler: index.handler
      Role: !GetAtt BackupLoggerRole.Arn
      Runtime: python3.9
      Timeout: 30
      Environment:
        Variables:
          SECONDARY_VAULT_ARN: !Ref SecondaryVaultArn
          ENABLE_COPY_TRIGGER: !Ref EnableCopyTrigger
          DESTINATION_RETENTION_DAYS: !Ref DestinationRetentionDays
      Code:
        ZipFile: |
          import json
          import logging
          import os
          import boto3

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)
          backup_client = boto3.client('backup')

          def handler(event, context):
              print("RECEIVED_EVENT: " + json.dumps(event))

              # 1. Check Feature Flag
              if os.environ.get('ENABLE_COPY_TRIGGER', 'false').lower() != 'true':
                  logger.info("Copy trigger is DISABLED via environment variable.")
                  return {'statusCode': 200, 'body': 'Copy disabled'}

              detail = event.get('detail', {})
              detail_type = event.get('detail-type')
              state = detail.get('state')

              # 2. Check for Completed Copy Job
              # We expect "Copy Job State Change" and state "COMPLETED"
              if detail_type != "Copy Job State Change" or state != "COMPLETED":
                  logger.info("Event is not a completed Copy Job. Skipping.")
                  return {'statusCode': 200, 'body': 'Skipped'}

              # 3. Extract Info from Event
              # The 'destinationRecoveryPointArn' from the event is the SOURCE for our new copy job
              source_recovery_point_arn = detail.get('destinationRecoveryPointArn')
              iam_role_arn = detail.get('iamRoleArn')
              
              # We need the source vault NAME. The event gives us the destinationBackupVaultArn
              # because this event signifies the data just arrived here.
              current_vault_arn = detail.get('destinationBackupVaultArn')

              if not (source_recovery_point_arn and iam_role_arn and current_vault_arn):
                  logger.error("Missing required fields (recoveryPointArn, iamRole, or vaultArn) in event.")
                  return {'statusCode': 400, 'body': 'Invalid Event Data'}

              # Parse vault name from ARN (arn:aws:backup:region:account:backup-vault:name)
              try:
                  source_vault_name = current_vault_arn.split(':')[-1]
              except IndexError:
                  logger.error(f"Could not parse vault name from ARN: {current_vault_arn}")
                  return {'statusCode': 400, 'body': 'Invalid Vault ARN'}

              # 4. Get Configuration
              target_vault_arn = os.environ.get('SECONDARY_VAULT_ARN')
              retention_days = int(os.environ.get('DESTINATION_RETENTION_DAYS', '30'))

              if not target_vault_arn:
                  logger.error("SECONDARY_VAULT_ARN is not set.")
                  return {'statusCode': 500, 'body': 'Missing Target Config'}

              # 5. Trigger the Next Copy Job
              try:
                  logger.info(f"Starting chained copy for {source_recovery_point_arn} to {target_vault_arn}")
                  response = backup_client.start_copy_job(
                      RecoveryPointArn=source_recovery_point_arn,
                      SourceBackupVaultName=source_vault_name,
                      DestinationBackupVaultArn=target_vault_arn,
                      IamRoleArn=iam_role_arn,
                      Lifecycle={
                          'DeleteAfterDays': retention_days
                      }
                  )
                  logger.info(f"Chained Copy Job Started: {response['CopyJobId']}")
                  return {'statusCode': 200, 'body': f"Copy started: {response['CopyJobId']}"}
              except Exception as e:
                  logger.error(f"Failed to start copy job: {str(e)}")
                  raise e

Outputs:

  BackupVaultName:
    Description: The name of the created Backup Vault.
    Value: !Ref EncryptedBackupVault
  
  BackupVaultArn:
    Description: The ARN of the created Backup Vault.
    Value: !GetAtt EncryptedBackupVault.BackupVaultArn

  KmsKeyId:
    Description: The ID of the KMS key
    Value: !Ref KmsKeyForBackup
  
  KmsKeyArn:
    Description: The ARN of the KMS key
    Value: !GetAtt KmsKeyForBackup.Arn

  KmsKeyAliasName:
    Description: The alias of the KMS key
    Value: !Ref KmsKeyAlias